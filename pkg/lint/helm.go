package lint

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"helm.sh/helm/v3/pkg/action"
	"helm.sh/helm/v3/pkg/cli"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/getter"
	"helm.sh/helm/v3/pkg/lint/support"
)

func WithHelm(client *action.Lint, valueOpts *values.Options, paths []string) error {
	fmt.Print("\n#################### lint by helm ####################\n")
	if client.WithSubcharts {
		for _, p := range paths {
			if err := filepath.Walk(filepath.Join(p, "charts"), func(path string, info os.FileInfo, err error) error {
				if info != nil {
					if info.Name() == "Chart.yaml" {
						paths = append(paths, filepath.Dir(path))
					} else if strings.HasSuffix(path, ".tgz") || strings.HasSuffix(path, ".tar.gz") {
						paths = append(paths, path)
					}
				}
				return nil
			}); err != nil {
				return err
			}
		}
	}

	var settings = cli.New()
	client.Namespace = settings.Namespace()
	vals, err := valueOpts.MergeValues(getter.All(settings))
	if err != nil {
		return err
	}

	var message strings.Builder
	failed := 0
	errorsOrWarnings := 0

	for _, path := range paths {
		result := client.Run([]string{path}, vals)

		// If there is no errors/warnings and quiet flag is set
		// go to the next chart
		hasWarningsOrErrors := action.HasWarningsOrErrors(result)
		if hasWarningsOrErrors {
			errorsOrWarnings++
		}
		if client.Quiet && !hasWarningsOrErrors {
			continue
		}

		fmt.Fprintf(&message, "==> Linting %s\n", path)

		// All the Errors that are generated by a chart
		// that failed a lint will be included in the
		// results.Messages so we only need to print
		// the Errors if there are no Messages.
		if len(result.Messages) == 0 {
			for _, err := range result.Errors {
				fmt.Fprintf(&message, "Error %s\n", err)
			}
		}

		for _, msg := range result.Messages {
			if !client.Quiet || msg.Severity > support.InfoSev {
				fmt.Fprintf(&message, "%s\n", msg)
			}
		}

		if len(result.Errors) != 0 {
			failed++
		}

		// Adding extra new line here to break up the
		// results, stops this from being a big wall of
		// text and makes it easier to follow.
		fmt.Fprint(&message, "\n")
	}

	fmt.Print(message.String())

	summary := fmt.Sprintf("%d chart(s) linted, %d chart(s) failed", len(paths), failed)
	if failed > 0 {
		return fmt.Errorf(summary)
	}
	if !client.Quiet || errorsOrWarnings > 0 {
		fmt.Print(summary)
	}
	return nil
}
