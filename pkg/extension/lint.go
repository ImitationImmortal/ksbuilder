package extension

import (
	"fmt"
	"os"
	"strings"

	"helm.sh/helm/v3/pkg/action"
	"helm.sh/helm/v3/pkg/chartutil"
	"helm.sh/helm/v3/pkg/cli"
	"helm.sh/helm/v3/pkg/cli/values"
	"helm.sh/helm/v3/pkg/engine"
	"helm.sh/helm/v3/pkg/getter"
	"helm.sh/helm/v3/pkg/lint/support"
	"k8s.io/apimachinery/pkg/util/rand"
	"path/filepath"
	"sigs.k8s.io/yaml"

	"github.com/kubesphere/ksbuilder/cmd/options"
	"github.com/kubesphere/ksbuilder/pkg/helm"
)

func WithHelm(o *options.LintOptions, paths []string) error {
	fmt.Print("\n#################### lint by helm ####################\n")
	if o.Client.WithSubcharts {
		for _, p := range paths {
			if err := filepath.Walk(filepath.Join(p, "charts"), func(path string, info os.FileInfo, err error) error {
				if info != nil {
					if info.Name() == "Chart.yaml" {
						paths = append(paths, filepath.Dir(path))
					} else if strings.HasSuffix(path, ".tgz") || strings.HasSuffix(path, ".tar.gz") {
						paths = append(paths, path)
					}
				}
				return nil
			}); err != nil {
				return err
			}
		}
	}

	o.Client.Namespace = o.Settings.Namespace()
	vals, err := o.ValueOpts.MergeValues(getter.All(o.Settings))
	if err != nil {
		return err
	}

	var message strings.Builder
	failed := 0
	errorsOrWarnings := 0

	for _, path := range paths {
		metadata, err := LoadMetadata(paths[0])
		if err != nil {
			return err
		}
		chartYaml, err := metadata.ToChartYaml()
		if err != nil {
			return err
		}

		result := helm.Lint(o.Client, []string{path}, vals, chartYaml)

		// If there is no errors/warnings and quiet flag is set
		// go to the next chart
		hasWarningsOrErrors := action.HasWarningsOrErrors(result)
		if hasWarningsOrErrors {
			errorsOrWarnings++
		}
		if o.Client.Quiet && !hasWarningsOrErrors {
			continue
		}

		fmt.Fprintf(&message, "==> Linting %s\n", path)

		// All the Errors that are generated by a chart
		// that failed a lint will be included in the
		// results.Messages so we only need to print
		// the Errors if there are no Messages.
		if len(result.Messages) == 0 {
			for _, err := range result.Errors {
				fmt.Fprintf(&message, "Error %s\n", err)
			}
		}

		for _, msg := range result.Messages {
			if !o.Client.Quiet || msg.Severity > support.InfoSev {
				fmt.Fprintf(&message, "%s\n", msg)
			}
		}

		if len(result.Errors) != 0 {
			failed++
		}

		// Adding extra new line here to break up the
		// results, stops this from being a big wall of
		// text and makes it easier to follow.
		fmt.Fprint(&message, "\n")
	}

	fmt.Print(message.String())

	summary := fmt.Sprintf("%d chart(s) linted, %d chart(s) failed", len(paths), failed)
	if failed > 0 {
		return fmt.Errorf(summary)
	}
	if !o.Client.Quiet || errorsOrWarnings > 0 {
		fmt.Print(summary)
	}
	return nil
}

func WithBuiltins(paths []string) error {
	fmt.Print("\n#################### lint by kubesphere ####################\n")
	ext, err := Load(paths[0])
	if err != nil {
		return err
	}

	// check images if exists
	if len(ext.Metadata.Images) == 0 {
		fmt.Printf("WARNING: extension %s has no images\n", paths[0])
	}

	chartYaml, err := ext.Metadata.ToChartYaml()
	if err != nil {
		return err
	}
	chartRequested, err := helm.Load(paths[0], chartYaml)
	if err != nil {
		return err
	}

	// check if value is valid
	valueValidators := []*lintValuesValidator{
		{
			name: "global.imageRegistry",
			key:  rand.String(12),
			valueFunc: func(v *lintValuesValidator) string {
				return fmt.Sprintf("global.imageRegistry=%s", v.key)
			},
			output: make(map[string]string),
		},
		{
			name: "global.nodeSelector",
			key:  rand.String(12),
			valueFunc: func(v *lintValuesValidator) string {
				return fmt.Sprintf("global.nodeSelector=\"kubernetes.io/os: %s\"", v.key)
			},
			output: make(map[string]string),
		},
	}

	valueOpts := &values.Options{}
	for _, vt := range valueValidators {
		valueOpts.Values = append(valueOpts.Values, vt.InitValue())
	}

	p := getter.All(cli.New())
	vals, err := valueOpts.MergeValues(p)
	if err != nil {
		return err
	}

	if err := chartutil.ProcessDependenciesWithMerge(chartRequested, vals); err != nil {
		return err
	}

	topVals, err := chartutil.CoalesceValues(chartRequested, vals)
	if err != nil {
		return err
	}
	top := map[string]interface{}{
		"Chart":        chartRequested.Metadata,
		"Capabilities": chartutil.DefaultCapabilities.Copy(),
		// set Release undefined
		"Release": map[string]interface{}{
			"Name":      "undefined",
			"Namespace": "undefined",
			"Revision":  1,
			"Service":   "Helm",
		},
		"Values": topVals,
	}

	files, err := engine.Render(chartRequested, top)
	if err != nil {
		return err
	}

	for name, content := range files {
		for _, vt := range valueValidators {
			if err := vt.Validate(name, content); err != nil {
				return err
			}
		}

	}

	for _, vt := range valueValidators {
		vt.Output()
	}

	return nil
}

type lintValuesValidator struct {
	name      string
	key       string
	valueFunc func(v *lintValuesValidator) string
	output    map[string]string
}

func (v *lintValuesValidator) InitValue() string {
	return v.valueFunc(v)
}

func (v *lintValuesValidator) Validate(fileName string, fileData string) error {
	yamlArr := strings.Split(fileData, "---")
	for _, y := range yamlArr {
		if strings.Contains(y, v.key) {
			yamlMap := make(map[string]any)
			if err := yaml.Unmarshal([]byte(y), &yamlMap); err != nil {
				return err
			}
			v.output[fileName] += fmt.Sprintf("name: %s, groupVersion: %s, kind: %s \n", yamlMap["metadata"].(map[string]any)["name"], yamlMap["apiVersion"], yamlMap["kind"])
		}
	}
	return nil
}

func (v *lintValuesValidator) Output() {
	fmt.Printf("INFO: \"%s\" is valid in: \n", v.name)
	if len(v.output) != 0 {
		for fileName, keyStr := range v.output {
			fmt.Printf("  %s: \n%s", fileName, keyStr)
		}
		fmt.Print("\n")
	}
}
